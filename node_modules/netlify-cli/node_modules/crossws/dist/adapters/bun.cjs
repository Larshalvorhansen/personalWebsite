'use strict';

const peer = require('../shared/crossws.6009d265.cjs');

const bun = peer.defineWebSocketAdapter(
  (hooks, options = {}) => {
    const crossws = peer.createCrossWS(hooks, options);
    const getWSPeer = (ws) => {
      if (ws.data?._peer) {
        return ws.data._peer;
      }
      const peer = new BunWSPeer({ bun: { ws } });
      ws.data = ws.data || {};
      ws.data._peer = peer;
      return peer;
    };
    return {
      async handleUpgrade(req, server) {
        const { headers } = await crossws.upgrade({
          url: req.url,
          headers: req.headers
        });
        return server.upgrade(req, {
          data: { req, server },
          headers
        });
      },
      websocket: {
        message: (ws, message) => {
          const peer$1 = getWSPeer(ws);
          crossws.$("bun:message", peer$1, ws, message);
          crossws.message(peer$1, new peer.WSMessage(message));
        },
        open: (ws) => {
          const peer = getWSPeer(ws);
          crossws.$("bun:open", peer, ws);
          crossws.open(peer);
        },
        close: (ws) => {
          const peer = getWSPeer(ws);
          crossws.$("bun:close", peer, ws);
          crossws.close(peer, {});
        },
        drain: (ws) => {
          const peer = getWSPeer(ws);
          crossws.$("bun:drain", peer);
        },
        ping(ws, data) {
          const peer = getWSPeer(ws);
          crossws.$("bun:ping", peer, ws, data);
        },
        pong(ws, data) {
          const peer = getWSPeer(ws);
          crossws.$("bun:pong", peer, ws, data);
        }
      }
    };
  }
);
class BunWSPeer extends peer.WSPeer {
  get id() {
    let addr = this.ctx.bun.ws.remoteAddress;
    if (addr.includes(":")) {
      addr = `[${addr}]`;
    }
    return addr;
  }
  get readyState() {
    return this.ctx.bun.ws.readyState;
  }
  get url() {
    return this.ctx.bun.ws.data.req?.url || "/";
  }
  get headers() {
    return this.ctx.bun.ws.data.req?.headers || new Headers();
  }
  send(message, options) {
    return this.ctx.bun.ws.send(peer.toBufferLike(message), options?.compress);
  }
  publish(topic, message, options) {
    return this.ctx.bun.ws.publish(
      topic,
      peer.toBufferLike(message),
      options?.compress
    );
  }
  subscribe(topic) {
    this.ctx.bun.ws.subscribe(topic);
  }
  unsubscribe(topic) {
    this.ctx.bun.ws.unsubscribe(topic);
  }
}

module.exports = bun;
