'use strict';

function defineWebSocketAdapter(factory) {
  return factory;
}

function createCrossWS(hooks, options) {
  const _callHook = options.resolve ? async function(name, info, ...args) {
    const hooks2 = await options.resolve?.(info);
    const hook = hooks2?.[name];
    return hook?.(info, ...args);
  } : void 0;
  return {
    async $(name, ...args) {
      await Promise.all([hooks.$?.(name, ...args), _callHook?.(name, ...args)]);
    },
    async upgrade(req) {
      const upgradeResults = await Promise.all([
        hooks.upgrade?.(req),
        _callHook?.("upgrade", req)
      ]);
      const headers = /* @__PURE__ */ Object.create(null);
      for (const result of upgradeResults) {
        if (result?.headers) {
          Object.assign(headers, result.headers);
        }
      }
      return { headers };
    },
    async message(peer, message) {
      await Promise.all([
        hooks.message?.(peer, message),
        _callHook?.("message", peer, message)
      ]);
    },
    async open(peer) {
      await Promise.all([hooks.open?.(peer), _callHook?.("open", peer)]);
    },
    async close(peer, { code, reason }) {
      await Promise.all([
        hooks.close?.(peer, { code, reason }),
        _callHook?.("close", peer, { code, reason })
      ]);
    },
    async error(peer, error) {
      await Promise.all([
        hooks.error?.(peer, error),
        _callHook?.("error", peer, error)
      ]);
    }
  };
}

function toBufferLike(val) {
  if (val === void 0 || val === null) {
    return "";
  }
  if (typeof val === "string") {
    return val;
  }
  if (isPlainObject(val)) {
    return JSON.stringify(val);
  }
  return val;
}
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

class WSMessage {
  constructor(rawData, isBinary) {
    this.rawData = rawData;
    this.isBinary = isBinary;
  }
  text() {
    if (typeof this.rawData === "string") {
      return this.rawData;
    }
    const buff = toBufferLike(this.rawData);
    if (typeof buff === "string") {
      return buff;
    }
    return new TextDecoder().decode(buff);
  }
  toString() {
    return this.text();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.text();
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const ReadyStateMap = {
  "-1": "unknown",
  0: "connecting",
  1: "open",
  2: "closing",
  3: "closed"
};
class WSPeer {
  constructor(ctx) {
    this.ctx = ctx;
    __publicField(this, "_subscriptions", /* @__PURE__ */ new Set());
  }
  get id() {
    return "??";
  }
  get url() {
    return "/";
  }
  get headers() {
    return {};
  }
  get readyState() {
    return -1;
  }
  publish(topic, message, options) {
  }
  subscribe(topic) {
    this._subscriptions.add(topic);
  }
  unsubscribe(topic) {
    this._subscriptions.delete(topic);
  }
  toString() {
    return `${this.id || ""}${this.readyState === 1 || this.readyState === -1 ? "" : ` [${ReadyStateMap[this.readyState]}]`}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}

exports.WSMessage = WSMessage;
exports.WSPeer = WSPeer;
exports.createCrossWS = createCrossWS;
exports.defineWebSocketAdapter = defineWebSocketAdapter;
exports.toBufferLike = toBufferLike;
