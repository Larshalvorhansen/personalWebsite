declare class WebSocketError extends Error {
    constructor(...args: any[]);
}

declare class WSMessage {
    readonly rawData: any;
    readonly isBinary?: boolean | undefined;
    constructor(rawData: any, isBinary?: boolean | undefined);
    text(): string;
    toString(): string;
}

type ReadyState = 0 | 1 | 2 | 3;
interface WSRequest {
    readonly url: string;
    readonly headers: HeadersInit;
}
declare abstract class WSPeer<AdapterContext = any> implements WSRequest {
    ctx: AdapterContext;
    _subscriptions: Set<string>;
    constructor(ctx: AdapterContext);
    get id(): string | undefined;
    get url(): string;
    get headers(): HeadersInit;
    get readyState(): ReadyState | -1;
    abstract send(message: any, options?: {
        compress?: boolean;
    }): number;
    publish(topic: string, message: any, options?: {
        compress?: boolean;
    }): void;
    subscribe(topic: string): void;
    unsubscribe(topic: string): void;
    toString(): string;
}

type MaybePromise<T> = T | Promise<T>;
type _UserHooks = WebSocketHooks & AdapterHooks;
type UserHooks = Partial<_UserHooks>;
declare function defineWebSocketHooks<T extends UserHooks = UserHooks>(hooks: T): T;
type UserHookName = Exclude<keyof _UserHooks, "$">;
type CatchAllHandler = <Name extends UserHookName>(name: Name, ...args: Parameters<_UserHooks[Name]>) => MaybePromise<void>;
interface WebSocketHooks {
    /** Catch-all handler */
    $: CatchAllHandler;
    /** Upgrading */
    upgrade: (req: WSRequest) => MaybePromise<void | {
        headers?: HeadersInit;
    }>;
    /** A message is received */
    message: (peer: WSPeer, message: WSMessage) => MaybePromise<void>;
    /** A socket is opened */
    open: (peer: WSPeer) => MaybePromise<void>;
    /** A socket is closed */
    close: (peer: WSPeer, details: {
        code?: number;
        reason?: string;
    }) => MaybePromise<void>;
    /** An error occurs */
    error: (peer: WSPeer, error: WebSocketError) => MaybePromise<void>;
}
type WSHook<ArgsT extends Array<any> = []> = (peer: WSPeer, ...args: ArgsT) => MaybePromise<void>;
interface AdapterHooks {
    "bun:message": WSHook<[ws: any, message: any]>;
    "bun:open": WSHook<[ws: any]>;
    "bun:close": WSHook<[ws: any]>;
    "bun:drain": WSHook<[]>;
    "bun:error": WSHook<[ws: any, error: any]>;
    "bun:ping": WSHook<[ws: any, data: any]>;
    "bun:pong": WSHook<[ws: any, data: any]>;
    "cloudflare:accept": WSHook<[]>;
    "cloudflare:message": WSHook<[event: any]>;
    "cloudflare:error": WSHook<[event: any]>;
    "cloudflare:close": WSHook<[event: any]>;
    "deno:open": WSHook<[]>;
    "deno:message": WSHook<[event: any]>;
    "deno:close": WSHook<[]>;
    "deno:error": WSHook<[error: any]>;
    "node:open": WSHook<[]>;
    "node:message": WSHook<[data: any, isBinary: boolean]>;
    "node:close": WSHook<[code: number, reason: Buffer]>;
    "node:error": WSHook<[error: any]>;
    "node:ping": WSHook<[data: Buffer]>;
    "node:pong": WSHook<[data: Buffer]>;
    "node:unexpected-response": WSHook<[req: any, res: any]>;
    "node:upgrade": WSHook<[req: any]>;
    "uws:open": WSHook<[ws: any]>;
    "uws:message": WSHook<[ws: any, message: any, isBinary: boolean]>;
    "uws:close": WSHook<[ws: any, code: number, message: any]>;
    "uws:ping": WSHook<[ws: any, message: any]>;
    "uws:pong": WSHook<[ws: any, message: any]>;
    "uws:drain": WSHook<[ws: any]>;
    "uws:upgrade": WSHook<[res: any, req: any, context: any]>;
    "uws:subscription": WSHook<[
        ws: any,
        topic: any,
        newCount: number,
        oldCount: number
    ]>;
}

type WebSocketAdapter<RT = any, OT = any> = (hooks: Partial<WebSocketHooks & AdapterHooks>, opts: OT) => RT;
declare function defineWebSocketAdapter<RT, OT>(factory: WebSocketAdapter<RT, OT>): WebSocketAdapter<RT, OT>;

interface CrossWS extends WebSocketHooks {
    upgrade: (req: WSRequest) => Promise<{
        headers: HeadersInit;
    }>;
}
interface CrossWSOptions {
    resolve?: (info: WSRequest | WSPeer) => UserHooks | Promise<UserHooks>;
}
declare function createCrossWS(hooks: UserHooks, options: CrossWSOptions): CrossWS;

export { type AdapterHooks, type CrossWS, type CrossWSOptions, type UserHooks, WSMessage, WSPeer, type WSRequest, type WebSocketAdapter, WebSocketError, type WebSocketHooks, type _UserHooks, createCrossWS, defineWebSocketAdapter, defineWebSocketHooks };
